AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for Q Business user group assignment Lambda'

Resources:
  RequestsLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: requests-layer
      Description: Layer containing requests package and requests-aws4auth
      Content:
        S3Bucket: !Ref LayerBucket
        S3Key: !Ref LayerKey      
      CompatibleRuntimes:
        - python3.12
      CompatibleArchitectures:
        - x86_64

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-user-group-assignment-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: QBusinessUserGroupAssignmentPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-user-group-assignment:*
              
              - Effect: Allow
                Action:
                  - qbusiness:GetApplication
                  - qbusiness:CancelSubscription
                  - qbusiness:CreateSubscription
                  - qbusiness:ListSubscriptions
                Resource: !Sub arn:aws:qbusiness:${AWS::Region}:${AWS::AccountId}:application/*
              
              - Effect: Allow
                Action:
                  - sso:CreateApplicationAssignment
                  - sso:DeleteApplicationAssignment
                  - sso:DescribeApplication
                Resource: !Sub arn:aws:sso::${AWS::AccountId}:application/*
              
              - Effect: Allow
                Action:
                  - user-subscriptions:CreateClaim
                  - user-subscriptions:UpdateClaim
                Resource: "*"
                Condition:
                  ForAnyValue:StringEquals:
                    aws:CalledVia:
                      - qbusiness.amazonaws.com
                      - user-subscriptions.amazonaws.com
              
              - Effect: Allow
                Action:
                  - sso-directory:DescribeUser
                  - sso-directory:DescribeGroup
                Resource: "*"
                Condition:
                  ForAnyValue:StringEquals:
                    aws:CalledVia:
                      - user-subscriptions.amazonaws.com
              
              - Effect: Allow
                Action:
                  - sso:DescribeInstance
                Resource: !Sub arn:aws:sso:${AWS::Region}:${AWS::AccountId}:instance/*

  QBusinessUserGroupAssignmentFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-user-group-assignment
      Handler: index.lambda_handler
      Description: Lambda function for Amazon Q Business user group assignment
      Runtime: python3.12
      Role: !GetAtt LambdaExecutionRole.Arn
      Layers:
        - !Ref RequestsLayer
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          import requests
          from requests_aws4auth import AWS4Auth
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          session = boto3.Session()
          credentials = session.get_credentials()
          qclient = session.client('qbusiness')
          ssoclient = session.client('sso-admin')

          def lambda_handler(event, context):
              try:
                  # Extract parameters from the event
                  region = event.get('region')
                  action = event['action'] 
                  applicationId = event['applicationId']
                  assignmentType = event.get('assignmentType')
                  assignmentId = event.get('assignmentId')
                  subscriptionType = event.get('subscriptionType')
                  subscriptionId = event.get('subscriptionId')
                  logger.info(f"Event parameters - region: {region}, action: {action}, applicationId: {applicationId}, assignmentType: {assignmentType}, assignmentId: {assignmentId}, subscriptionType: {subscriptionType}, subscriptionId: {subscriptionId}")   

                  # Validate action
                  if action not in ['ADD', 'DELETE']:
                      logger.error('Invalid action. Must be ADD, or DELETE')
                      return {
                          'statusCode': 400,
                          'body': json.dumps({
                              'error': 'Invalid action. Must be ADD, or DELETE'
                          })
                      }
                  
                  if action == 'ADD':
                      # Validate required parameters for ADD
                      if not all([applicationId, assignmentType, assignmentId, subscriptionType]):
                          logger.error('assignmentType, assignmentId, and subscriptionType are required for ADD action')
                          return {
                              'statusCode': 400,
                              'body': json.dumps({
                                  'error': 'assignmentType, assignmentId, and subscriptionType are required for ADD action'
                              })
                          }

                      # Validate subscription type
                      if subscriptionType not in ['Q_BUSINESS', 'Q_LITE']:
                          logger.error('Invalid subscription type. Must be Q_BUSINESS or Q_LITE')
                          return {
                              'statusCode': 400,
                              'body': json.dumps({
                                  'error': 'Invalid subscription type. Must be Q_BUSINESS or Q_LITE'
                              })
                          }

                      # Validate assignment type
                      if assignmentType not in ['GROUP', 'USER']:
                          logger.error('Invalid assignment type. Must be GROUP or USER')
                          return {
                              'statusCode': 400,
                              'body': json.dumps({
                                  'error': 'Invalid assignment type. Must be GROUP or USER'
                              })
                          }
                      
                      # Add subscription
                      result = add_subscription(
                          region,
                          applicationId,
                          assignmentType,
                          assignmentId,
                          subscriptionType
                      )
                      logger.info(f"Subscription added successfully: {result}")
                  
                  else:  # DELETE
                      if not all([applicationId, assignmentType, assignmentId]):
                          logger.error('assignmentType and assignmentId are required for DELETE action')
                          return {
                              'statusCode': 400,
                              'body': json.dumps({
                                  'error': 'assignmentType and assignmentId are required for DELETE action'
                              })
                          }
                          
                      delete_subscription(
                          region,
                          applicationId,
                          assignmentType,
                          assignmentId
                      )
                      
                      result = "Application assignment deleted successfully"
                      logger.info(result)
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(result)
                  }
                  
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': str(e)
                      })
                  }

          def delete_subscription(region, applicationId, assignmentType, assignmentId):
              #First find the Subscription Id for the given Application and User/Group
              endpoint = f'https://qbusiness.{region}.api.aws/applications/{applicationId}/subscriptions'
              subscriptions_data = make_qbusiness_request(region, 'GET', endpoint)

              if 'subscriptions' not in subscriptions_data:
                  logger.error("No subscriptions found for the given application")
                  raise Exception(f"No subscriptions found for the given application")
                  
              subscriptionId = ""
              for subscription in subscriptions_data['subscriptions']:
                  principal = subscription.get('principal', {})
                  if assignmentType.lower() in principal:
                      if principal[assignmentType.lower()] == assignmentId:
                          subscriptionId = subscription['subscriptionId']
                          break
              if subscriptionId == "":
                  logger.error("Subscription not found for the given application and principal")
                  raise Exception(f"Subscription not found for the given application and principal")
              
              #Now call DELETE on the endpoint to delete
              endpoint += f"/{subscriptionId}"
              make_qbusiness_request(region, 'DELETE', endpoint)
              logger.info(f"Subscription deleted successfully: {subscriptionId}")
              #Remove IDC App assignment
              ssoclient.delete_application_assignment(
                          ApplicationArn=qclient.get_application(applicationId=applicationId)["identityCenterApplicationArn"],
                          PrincipalId=assignmentId,
                          PrincipalType=assignmentType)
              logger.info(f"Application assignment deleted successfully: {assignmentId}")

          def add_subscription(region, applicationId, assignmentType, assignmentId, subscriptionType):
              # Create IAM Identity Center application assignment
              app = qclient.get_application(applicationId=applicationId)
              ssoclient.create_application_assignment(
                  ApplicationArn=app["identityCenterApplicationArn"],
                  PrincipalId=assignmentId,
                  PrincipalType=assignmentType
              )
              logger.info(f"Application assignment created successfully: {assignmentId}")
              
              endpoint = f'https://qbusiness.{region}.api.aws/applications/{applicationId}/subscriptions'
              
              payload = {
                  'principal': {assignmentType.lower(): assignmentId}, 
                  'type': subscriptionType
              }

              response = make_qbusiness_request(region, 'POST', endpoint, payload)
              logger.info(f"Subscription created successfully: {response}")
              return response["subscriptionId"]

          def make_qbusiness_request(region, method, endpoint, payload=None):
              headers = {
                  'Content-Type': 'application/json'
              }

              try:
                  aws_auth = AWS4Auth(
                      credentials.access_key,
                      credentials.secret_key,
                      region,
                      'qbusiness',
                      session_token=credentials.token
                  )

                  response = requests.request(
                      method=method,
                      url=endpoint,
                      auth=aws_auth,
                      headers=headers,
                      json=payload if payload else None,
                      timeout=120
                  )

                  response.raise_for_status()
                  logger.info(f"Request successful: {response.status_code}")
                  return response.json()

              except requests.exceptions.RequestException as e:
                  raise Exception(f"Request failed: {str(e)}")

      Timeout: 300
      MemorySize: 128
      Environment:
        Variables:
          ENVIRONMENT: prod

Parameters:
  LayerBucket:
    Type: String
    Description: S3 bucket containing the Lambda layer zip file
  LayerKey:
    Type: String 
    Description: S3 key for the Lambda layer zip file  
    
Outputs:
  LambdaFunctionArn:
    Description: ARN of the Lambda function
    Value: !GetAtt QBusinessUserGroupAssignmentFunction.Arn
  
  LambdaRoleArn:
    Description: ARN of the Lambda execution role
    Value: !GetAtt LambdaExecutionRole.Arn
