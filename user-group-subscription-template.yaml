AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for Q Business user group assignment Lambda'

Resources:
  RequestsLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub ${AWS::StackName}-requests-layer
      Description: Layer containing requests package and requests-aws4auth
      Content:
        S3Bucket: !Ref LayerBucket
        S3Key: !Ref LayerKey      
      CompatibleRuntimes:
        - python3.12
      CompatibleArchitectures:
        - x86_64

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-user-group-assignment-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-user-group-assignment:*
              
              - Effect: Allow
                Action:
                  - qbusiness:GetApplication
                  - qbusiness:CancelSubscription
                  - qbusiness:CreateSubscription
                  - qbusiness:ListSubscriptions
                Resource: !Sub arn:aws:qbusiness:${AWS::Region}:${AWS::AccountId}:application/*
              
              - Effect: Allow
                Action:
                  - sso:CreateApplicationAssignment
                  - sso:DeleteApplicationAssignment
                  - sso:DescribeApplication
                Resource: !Sub arn:aws:sso::${AWS::AccountId}:application/*
              
              - Effect: Allow
                Action:
                  - user-subscriptions:CreateClaim
                  - user-subscriptions:UpdateClaim
                Resource: "*"
                Condition:
                  ForAnyValue:StringEquals:
                    aws:CalledVia:
                      - qbusiness.amazonaws.com
                      - user-subscriptions.amazonaws.com
              
              - Effect: Allow
                Action:
                  - sso-directory:DescribeUser
                  - sso-directory:DescribeGroup
                  - sso:DescribeInstance
                Resource: "*"
                Condition:
                  ForAnyValue:StringEquals:
                    aws:CalledVia:
                      - user-subscriptions.amazonaws.com
  QBusinessUserGroupAssignmentFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-user-group-assignment
      Handler: index.lambda_handler
      Description: Lambda function for Amazon Q Business user group assignment
      Runtime: python3.12
      Role: !GetAtt LambdaExecutionRole.Arn
      Layers:
        - !Ref RequestsLayer
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          import requests
          from requests_aws4auth import AWS4Auth
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          session = boto3.Session()
          credentials = session.get_credentials()
          qclient = session.client('qbusiness')
          ssoclient = session.client('sso-admin')

          def lambda_handler(event, context):

            try:
                # Extract HTTP method
                http_method = event['httpMethod']
                
                # Parse body for POST requests
                body = {}
                if http_method == 'POST' and 'body' in event:
                    body = json.loads(event['body'])
                    
                # Extract query parameters for DELETE requests
                query_params = event.get('queryStringParameters', {}) or {}
                
                if http_method == 'POST':
                    # Map to ADD action
                    payload = {
                        'action': 'ADD',
                        'region': body.get('region'),
                        'applicationId': body.get('applicationId'),
                        'assignmentType': body.get('assignmentType'),
                        'assignmentId': body.get('assignmentId'),
                        'subscriptionType': body.get('subscriptionType')
                    }
                elif http_method == 'DELETE':
                    # Map to DELETE action
                    payload = {
                        'action': 'DELETE',
                        'region': query_params.get('region'),
                        'applicationId': query_params.get('applicationId'),
                        'assignmentType': query_params.get('assignmentType'),
                        'assignmentId': query_params.get('assignmentId')
                    }
                else:
                    return {
                        'statusCode': 400,
                        'body': json.dumps({
                            'error': 'Unsupported HTTP method'
                        })
                    }
                
                result = process_request(payload, context)
                
                # Return API Gateway response
                return {
                    'statusCode': result['statusCode'],
                    'headers': {
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    },
                    'body': result['body']
                }
                
            except Exception as e:
                return {
                    'statusCode': 500,
                    'headers': {
                        'Content-Type': 'application/json',
                        'Access-Control-Allow-Origin': '*'
                    },
                    'body': json.dumps({
                        'error': str(e)
                    })
                }


          def process_request(event, context):
              try:
                  # Extract parameters from the event
                  region = event.get('region')
                  action = event['action'] 
                  applicationId = event['applicationId']
                  assignmentType = event.get('assignmentType')
                  assignmentId = event.get('assignmentId')
                  subscriptionType = event.get('subscriptionType')
                  subscriptionId = event.get('subscriptionId')
                  logger.info(f"Event parameters - region: {region}, action: {action}, applicationId: {applicationId}, assignmentType: {assignmentType}, assignmentId: {assignmentId}, subscriptionType: {subscriptionType}, subscriptionId: {subscriptionId}")   

                  # Validate action
                  if action not in ['ADD', 'DELETE']:
                      logger.error('Invalid action. Must be ADD, or DELETE')
                      return {
                          'statusCode': 400,
                          'body': json.dumps({
                              'error': 'Invalid action. Must be ADD, or DELETE'
                          })
                      }
                  
                  if action == 'ADD':
                      # Validate required parameters for ADD
                      if not all([applicationId, assignmentType, assignmentId, subscriptionType]):
                          logger.error('assignmentType, assignmentId, and subscriptionType are required for ADD action')
                          return {
                              'statusCode': 400,
                              'body': json.dumps({
                                  'error': 'assignmentType, assignmentId, and subscriptionType are required for ADD action'
                              })
                          }

                      # Validate subscription type
                      if subscriptionType not in ['Q_BUSINESS', 'Q_LITE']:
                          logger.error('Invalid subscription type. Must be Q_BUSINESS or Q_LITE')
                          return {
                              'statusCode': 400,
                              'body': json.dumps({
                                  'error': 'Invalid subscription type. Must be Q_BUSINESS or Q_LITE'
                              })
                          }

                      # Validate assignment type
                      if assignmentType not in ['GROUP', 'USER']:
                          logger.error('Invalid assignment type. Must be GROUP or USER')
                          return {
                              'statusCode': 400,
                              'body': json.dumps({
                                  'error': 'Invalid assignment type. Must be GROUP or USER'
                              })
                          }
                      
                      # Add subscription
                      result = add_subscription(
                          region,
                          applicationId,
                          assignmentType,
                          assignmentId,
                          subscriptionType
                      )
                      logger.info(f"Subscription added successfully: {result}")
                  
                  else:  # DELETE
                      if not all([applicationId, assignmentType, assignmentId]):
                          logger.error('assignmentType and assignmentId are required for DELETE action')
                          return {
                              'statusCode': 400,
                              'body': json.dumps({
                                  'error': 'assignmentType and assignmentId are required for DELETE action'
                              })
                          }
                          
                      delete_subscription(
                          region,
                          applicationId,
                          assignmentType,
                          assignmentId
                      )
                      
                      result = "{status:'Application assignment deleted successfully'}"
                      logger.info(result)
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(result)
                  }
                  
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': str(e)
                      })
                  }

          def delete_subscription(region, applicationId, assignmentType, assignmentId):
              #First find the Subscription Id for the given Application and User/Group
              endpoint = f'https://qbusiness.{region}.api.aws/applications/{applicationId}/subscriptions'
              subscriptions_data = make_qbusiness_request(region, 'GET', endpoint)

              if 'subscriptions' not in subscriptions_data:
                  logger.error("No subscriptions found for the given application")
                  raise Exception(f"No subscriptions found for the given application")
                  
              subscriptionId = ""
              for subscription in subscriptions_data['subscriptions']:
                  principal = subscription.get('principal', {})
                  if assignmentType.lower() in principal:
                      if principal[assignmentType.lower()] == assignmentId:
                          subscriptionId = subscription['subscriptionId']
                          break
              if subscriptionId == "":
                  logger.error("Subscription not found for the given application and principal")
                  raise Exception(f"Subscription not found for the given application and principal")
              
              #Now call DELETE on the endpoint to delete
              endpoint += f"/{subscriptionId}"
              make_qbusiness_request(region, 'DELETE', endpoint)
              logger.info(f"Subscription deleted successfully: {subscriptionId}")
              #Remove IDC App assignment
              ssoclient.delete_application_assignment(
                          ApplicationArn=qclient.get_application(applicationId=applicationId)["identityCenterApplicationArn"],
                          PrincipalId=assignmentId,
                          PrincipalType=assignmentType)
              logger.info(f"Application assignment deleted successfully: {assignmentId}")

          def add_subscription(region, applicationId, assignmentType, assignmentId, subscriptionType):
              # Create IAM Identity Center application assignment
              app = qclient.get_application(applicationId=applicationId)
              ssoclient.create_application_assignment(
                  ApplicationArn=app["identityCenterApplicationArn"],
                  PrincipalId=assignmentId,
                  PrincipalType=assignmentType
              )
              logger.info(f"Application assignment created successfully: {assignmentId}")
              
              endpoint = f'https://qbusiness.{region}.api.aws/applications/{applicationId}/subscriptions'
              
              payload = {
                  'principal': {assignmentType.lower(): assignmentId}, 
                  'type': subscriptionType
              }

              response = make_qbusiness_request(region, 'POST', endpoint, payload)
              logger.info(f"Subscription created successfully: {response}")
              return f"subscriptionId:{response['subscriptionId']}"

          def make_qbusiness_request(region, method, endpoint, payload=None):
              headers = {
                  'Content-Type': 'application/json'
              }

              try:
                  aws_auth = AWS4Auth(
                      credentials.access_key,
                      credentials.secret_key,
                      region,
                      'qbusiness',
                      session_token=credentials.token
                  )

                  response = requests.request(
                      method=method,
                      url=endpoint,
                      auth=aws_auth,
                      headers=headers,
                      json=payload if payload else None,
                      timeout=120
                  )

                  response.raise_for_status()
                  logger.info(f"Request successful: {response.status_code}")
                  return response.json()

              except requests.exceptions.RequestException as e:
                  raise Exception(f"Request failed: {str(e)}")

      Timeout: 300
      MemorySize: 128
      Environment:
        Variables:
          ENVIRONMENT: prod

  # API Gateway
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub ${AWS::StackName}-subscription-api
      Description: API for managing Q Business subscriptions
      EndpointConfiguration:
        Types:
          - REGIONAL

  # API Resource for /subscription
  SubscriptionResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: subscription

  # POST Method for adding subscriptions
  SubscriptionPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref SubscriptionResource
      HttpMethod: POST
      AuthorizationType: AWS_IAM
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${QBusinessUserGroupAssignmentFunction.Arn}/invocations

  # DELETE Method for removing subscriptions
  SubscriptionDeleteMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref SubscriptionResource
      HttpMethod: DELETE
      AuthorizationType: AWS_IAM
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${QBusinessUserGroupAssignmentFunction.Arn}/invocations

  # API Deployment
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - SubscriptionPostMethod
      - SubscriptionDeleteMethod
    Properties:
      RestApiId: !Ref ApiGateway

  # API Stage
  ApiStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      RestApiId: !Ref ApiGateway
      DeploymentId: !Ref ApiDeployment
      StageName: prod

  # Lambda Permission for API Gateway
  LambdaApiPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref QBusinessUserGroupAssignmentFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*/*


Parameters:
  LayerBucket:
    Type: String
    Description: S3 bucket containing the Lambda layer zip file
  LayerKey:
    Type: String 
    Description: S3 key for the Lambda layer zip file  
    
Outputs:
  ApiEndpoint:
    Description: API Gateway endpoint URL
    Value: !Sub https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod/subscription
